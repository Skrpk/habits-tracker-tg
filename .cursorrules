# Habits Tracker - Telegram Bot Project

## Project Overview

This is a TypeScript-based Telegram bot for habit tracking, deployed on Vercel. Users can create habits, track daily completion, maintain streaks, and skip days without breaking streaks. The bot sends reminders automatically via cron jobs based on each habit's custom schedule. Users can configure their timezone and set custom reminder schedules per habit (daily, weekly, monthly, or interval-based).

## Architecture

The project follows **Clean Architecture** principles with clear separation of concerns:

### Layer Structure

1. **Domain Layer** (`src/domain/`)
   - **Entities** (`entities/`): Core business objects (e.g., `Habit`, `UserHabits`, `UserPreferences`)
   - **Repositories** (`repositories/`): Interfaces defining data access contracts (e.g., `IHabitRepository`)
   - **Use Cases** (`use-cases/`): Business logic implementations
     - `CreateHabitUseCase`: Creates new habits
     - `DeleteHabitUseCase`: Deletes habits
     - `GetUserHabitsUseCase`: Retrieves user's habits
     - `GetHabitsToCheckUseCase`: Gets habits that need checking
     - `RecordHabitCheckUseCase`: Records habit completion/skipping
     - `SetUserPreferencesUseCase`: Manages user preferences (timezone)
     - `SetHabitReminderScheduleUseCase`: Sets/updates habit reminder schedules
     - `CheckHabitReminderDueUseCase`: Checks if a habit is due for reminder
     - `GetHabitsDueForReminderUseCase`: Gets all habits due for reminders across users

2. **Infrastructure Layer** (`src/infrastructure/`)
   - **Config** (`config/`): Redis client configuration (`kv.ts`)
   - **Repositories** (`repositories/`): Concrete implementations (e.g., `VercelKVHabitRepository`)
   - **Logger** (`logger/`): Structured logging utility

3. **Presentation Layer** (`src/presentation/`)
   - **Telegram** (`telegram/`): Telegram bot service and handlers
     - `TelegramBot.ts`: Main bot service handling commands and callbacks
     - `DailyReminderService.ts`: Manages reminder logic

## Key Features

1. **User Onboarding**
   - On first `/start`, users select their timezone from 24 options (covering UTC-12 to UTC+12)
   - Timezone preference is stored and used for all habit reminders
   - Users can change timezone later (stored in `UserPreferences`)

2. **Habit Management**
   - Create habits via `/newhabit` (multi-step conversation)
   - After creating a habit, users configure reminder schedule immediately
   - View all habits via `/myhabits`
   - Delete habits with confirmation
   - View habit details (streak, skipped days, reminder schedule, creation date)
   - Update reminder schedule for existing habits

3. **Habit Tracking**
   - Reminders sent automatically based on each habit's schedule
   - Three options when checking habits:
     - ✅ Yes (completes habit, increments streak)
     - ❌ No (drop streak) (resets streak to 0, clears skipped days)
     - ⏭️ Skip (keep streak) (records skipped day, maintains streak)

4. **Streak Management**
   - Streaks increment on consecutive completions
   - Streaks reset to 0 if habit is not completed (without skipping)
   - Skipped days are tracked in `skipped` array with `streakDay` and `date`
   - Skipped days count displayed in habit details

5. **Reminder Scheduling**
   - Each habit can have a custom reminder schedule:
     - **Daily**: Every day at a specific time (e.g., "20:30")
     - **Weekly**: On specific days of week (e.g., "monday,wednesday 18:00")
     - **Monthly**: On specific days of month (e.g., "15,30 22:00")
     - **Interval**: Every N days (e.g., "2 15:30" for every 2 days)
   - Schedules are configured in user's timezone
   - Default schedule: Daily at 22:00 in user's timezone
   - Reminders checked hourly via cron jobs
   - Production: Vercel Cron Jobs (`0 * * * *` - every hour at minute 0)
   - Development: Docker cron container (configurable schedule)

## File Structure

```
habits-tracker/
├── api/                          # Vercel serverless functions
│   ├── webhook.ts               # Telegram webhook handler
│   ├── reminders.ts             # Cron job endpoint for reminders
│   ├── analytics.ts             # Analytics API endpoint
│   └── setup-webhook.ts         # Manual webhook setup endpoint
├── src/
│   ├── domain/                  # Domain layer (business logic)
│   │   ├── entities/
│   │   ├── repositories/
│   │   ├── use-cases/
│   │   └── utils/               # Domain utilities
│   │       └── HabitAnalytics.ts # History inference logic
│   ├── infrastructure/          # Infrastructure layer (external services)
│   │   ├── config/             # Redis configuration
│   │   ├── logger/             # Logging utilities
│   │   └── repositories/       # Redis repository implementation
│   ├── presentation/            # Presentation layer (Telegram bot)
│   │   └── telegram/
│   ├── api/                    # Local development API servers
│   │   └── reminders-server.ts # Local HTTP server for reminders
│   └── index.ts                # Local development entry (polling mode)
├── public/                      # Static files served at root URL
│   ├── index.html              # Landing page
│   ├── analytics.html          # Analytics dashboard page
│   └── styles.css              # Landing page styles
├── scripts/                     # Utility scripts
│   └── setup-webhook.ts        # Webhook setup script
├── docker/                      # Docker configuration
│   └── cron/                   # Cron container files
├── docker-compose.yml          # Local development setup
├── Dockerfile.dev              # Bot service Dockerfile
├── vercel.json                 # Vercel deployment config
├── tsconfig.json               # TypeScript configuration
└── package.json                # Dependencies and scripts
```

## How It Works

### Production (Vercel)

1. **Webhook Mode**: Telegram sends updates to `/api/webhook`
   - Secured with `WEBHOOK_SECRET_TOKEN` (X-Telegram-Bot-Api-Secret-Token header)
   - Handles all bot commands and callback queries
   - Uses singleton pattern for bot service in serverless functions

2. **Cron Jobs**: Vercel Cron calls `/api/reminders` hourly at minute 0
   - Secured with `x-vercel-cron` header and `Authorization` header
   - Fetches all active users from Redis
   - For each user, converts server time to user's timezone
   - Checks which habits are due for reminders based on their schedules
   - Sends reminder messages for habits that are due and not yet checked today

3. **Static Files**: `public/` folder served at root URL (`/`)
   - Landing page with quote and features
   - Analytics page at `/analytics/{userId}` (served via `api/analytics.ts`)
   - API routes remain functional at `/api/*`

4. **Analytics API**: `/api/analytics` endpoint
   - Serves analytics HTML page for authenticated users
   - Fetches user habits from Redis
   - Computes check history for each habit using `computeCheckHistory()`
   - Returns HTML with embedded habit data as JSON
   - Accessible via `/analytics/{userId}` route

### Development (Local)

1. **Docker Compose**: Runs three services
   - `redis`: Redis database (port 6379)
   - `bot`: Bot service with hot-reload (port 3000)
   - `cron`: Cron daemon calling reminders endpoint

2. **Polling Mode**: `src/index.ts` uses Telegram polling
   - Only runs locally (not deployed)
   - Handles updates via long polling

3. **Reminders Server**: `src/api/reminders-server.ts`
   - Local HTTP server mimicking Vercel serverless function
   - Called by Docker cron container

## Data Models

### Habit Entity
```typescript
interface Habit {
  id: string;
  userId: number;
  name: string;
  streak: number;
  createdAt: Date;
  lastCheckedDate: string; // YYYY-MM-DD
  skipped: SkippedDay[];  // Array of skipped days
  reminderSchedule?: ReminderSchedule; // Custom reminder schedule
  reminderEnabled?: boolean; // Whether reminders are enabled (default true)
}

interface SkippedDay {
  streakDay: number;      // Streak day when skipped
  date: string;          // YYYY-MM-DD format
}

interface DroppedDay {
  streakBeforeDrop: number; // Streak value before the drop
  date: string;            // YYYY-MM-DD format
}

interface CheckHistoryEntry {
  date: string;           // YYYY-MM-DD format
  type: 'completed' | 'skipped' | 'dropped';
  streak: number;         // Streak value at this point
  streakBefore?: number;  // For drops: streak before the drop
}

type ReminderSchedule =
  | { type: 'daily'; hour: number; minute: number; timezone?: string }
  | { type: 'weekly'; daysOfWeek: number[]; hour: number; minute: number; timezone?: string }
  | { type: 'monthly'; daysOfMonth: number[]; hour: number; minute: number; timezone?: string }
  | { type: 'interval'; intervalDays: number; hour: number; minute: number; timezone?: string; startDate?: string };
```

### UserPreferences Entity
```typescript
interface UserPreferences {
  userId: number;
  user?: TelegramBot.User; // Full Telegram user object with all user information
  timezone?: string; // IANA timezone (e.g., "America/New_York", "Europe/London")
  consentAccepted?: boolean; // Whether user has accepted the privacy policy and terms
  consentDate?: string; // ISO date string when consent was given (YYYY-MM-DD)
}
```

### Storage
- Redis keys: `user:habits:{userId}` for user habits
- Redis keys: `user:{userId}:preferences` for user preferences (timezone)
- Redis keys: `active_users` for tracking users with habits
- Redis keys: `conversation_state:{userId}` for multi-step conversations

## Environment Variables

### Required
- `TELEGRAM_BOT_TOKEN`: Telegram bot token
- `REDIS_URL`: Redis connection string (Vercel Redis or local)

### Optional
- `WEBHOOK_URL`: Full URL for webhook (production)
- `WEBHOOK_SECRET_TOKEN`: Secret token for webhook security
- `USE_LOCAL_REDIS`: Set to `true` for local development
- `NODE_ENV`: `production` or `development`
- `CRON_SECRET`: Secret for local cron endpoint (optional)
- `CRON_SCHEDULE`: Cron schedule for local development (default: `* * * * *`)
- `NOTIFICATION_CHANNEL_ID`: Telegram channel ID for new user notifications (optional)

## Important Patterns

1. **Manual Update Handling**: All Telegram updates are manually routed in `TelegramBotService.processUpdate()` to ensure async operations complete before serverless function returns.

2. **Conversation State**: Multi-step conversations (e.g., `/newhabit`, schedule configuration) use Redis to store state, not in-memory maps (for serverless compatibility). States include:
   - `creating_habit`: Waiting for habit name
   - `setting_schedule_new:{habitId}`: Configuring schedule for new habit
   - `set_schedule:{habitId}:{scheduleType}`: Configuring schedule for existing habit

3. **Timezone Handling**: 
   - Users must set timezone on first `/start` command
   - All habit schedules are stored with user's timezone
   - Reminder checking converts server UTC time to each user's timezone
   - Schedule descriptions display times in user's timezone

4. **Schedule Configuration**:
   - During habit creation, users configure schedule immediately after naming
   - Simplified input format: "20:30" for daily, "monday 15:48" for weekly, etc.
   - Schedule type is selected via buttons, then user enters simplified format
   - Users can skip schedule configuration to use default (daily 22:00 in their timezone)

5. **Error Handling**: `safeEditMessage()` helper ignores "message is not modified" errors from Telegram.

6. **Logging**: Structured logging via `Logger` utility with timestamps and metadata.

7. **Redis Connection**: Connection is managed per-request in serverless functions with connection pooling and timeout handling.

8. **Bot Commands Menu**: Bot commands are set via `setMyCommands()` on initialization:
   - `/start` - Start the bot and set your timezone
   - `/newhabit` - Create a new habit to track
   - `/myhabits` - View all your habits
   - `/analytics` - Get link to your personal analytics dashboard

9. **Analytics Data Inference** (`computeCheckHistory`):
   - Reconstructs habit history from minimal stored data (no per-day storage)
   - Only infers completions when `streak > 0` OR there are skipped/dropped days (user interaction)
   - Works backwards from today to match stored streak value exactly
   - Processes all days from creation to today, but only marks completions for:
     - Current streak period (most recent N days where N = streak)
     - Pre-drop streaks (using `streakBeforeDrop` from drop events)
   - Handles drops (reset streak to 0) and skips (preserve streak)
   - Supports all schedule types (daily, weekly, monthly, interval)
   - Returns chronological history with correct streak progression

## Build Process

1. TypeScript compilation (`tsc`)
2. Remove `dist/index.js` (prevents Vercel from treating it as serverless function)
3. Copy `public/*` to `dist/` (for static file serving)

## Development Commands

- `npm run dev`: Start bot in polling mode (local)
- `npm run dev:reminders`: Start local reminders server
- `npm run build`: Build for production
- `npm run setup-webhook`: Set Telegram webhook (production)
- `docker-compose up`: Start local development environment

## Security Considerations

1. **Webhook Security**: `WEBHOOK_SECRET_TOKEN` verified in `X-Telegram-Bot-Api-Secret-Token` header
2. **Cron Security**: `x-vercel-cron` header and `Authorization` header verified
3. **Input Validation**: Command injection prevention (commands can't be used as habit names)

## Notes

- The bot uses webhooks in production and polling in development
- Redis is used directly (not Vercel KV) - connection string format: `redis://` or `rediss://`
- All async operations in Telegram handlers are awaited to prevent premature function termination
- The `/check` command was removed - reminders are automatic only
- Reminders are checked hourly (not daily) to support custom schedules
- Each habit can have its own reminder schedule and timezone
- User timezone is required - set on first `/start`, stored in `UserPreferences`
- Schedule input is simplified: users select type via button, then enter simplified format (e.g., "20:30" for daily)
- Landing page quote is from Plutarch: "Choose what is best, and habit will make it pleasant and easy."
- Analytics page uses Chart.js and chartjs-plugin-zoom for interactive visualizations
- Analytics history inference ensures data accuracy: only infers completions when there's evidence of user interaction
- The analytics page is client-side rendered with embedded JSON data for better performance

